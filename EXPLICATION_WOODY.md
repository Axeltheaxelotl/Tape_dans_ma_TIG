# ğŸªµ WOODY_WOODPACKER - Explication DÃ©taillÃ©e

## ğŸ“š Table des matiÃ¨res
1. [Vue d'ensemble](#vue-densemble)
2. [Architecture ELF](#architecture-elf)
3. [Processus de chiffrement](#processus-de-chiffrement)
4. [Processus d'injection](#processus-dinjection)
5. [Code de dÃ©cryptage](#code-de-dÃ©cryptage)
6. [Calculs d'offsets](#calculs-doffsets)
7. [SchÃ©mas dÃ©taillÃ©s](#schÃ©mas-dÃ©taillÃ©s)

---

## ğŸ¯ Vue d'ensemble

**Woody_woodpacker** est un packer ELF qui :
1. **Chiffre** le segment `.text` (code exÃ©cutable) d'un binaire ELF
2. **Injecte** un stub de dÃ©cryptage dans le binaire
3. **Modifie** le point d'entrÃ©e pour exÃ©cuter d'abord le stub
4. **Restaure** l'exÃ©cution normale aprÃ¨s dÃ©cryptage

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    WORKFLOW GÃ‰NÃ‰RAL                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Binaire Original         Woody_woodpacker         Binaire PackÃ©
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ELF Header   â”‚              â”‚                  â”‚ ELF Header   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ .text        â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ .text        â”‚
â”‚ (plain)      â”‚   Chiffre    â”‚                  â”‚ (chiffrÃ©!)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ .data        â”‚              â”‚                  â”‚ .data        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ...          â”‚              â”‚                  â”‚ ...          â”‚
â”‚              â”‚              â”‚                  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              â”‚              â”‚    Injecte       â”‚ STUB         â”‚
â”‚              â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ - Decrypt    â”‚
â”‚              â”‚              â”‚                  â”‚ - Key        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚                  â”‚ - Jump back  â”‚
                              â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     Entry: 0x1000            â”‚                  Entry: 0x23540
                              â”‚                  (pointe vers STUB)
```

---

## ğŸ—ï¸ Architecture ELF

### Structure d'un fichier ELF

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FICHIER ELF 64-bit                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Offset 0x0
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ELF Header (Elf64_Ehdr)                                       â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ e_ident[16]   : Magic + Class + Endian + Version        â”‚ â”‚
â”‚ â”‚ e_type        : ET_EXEC ou ET_DYN                        â”‚ â”‚
â”‚ â”‚ e_machine     : EM_X86_64 ou EM_386                      â”‚ â”‚
â”‚ â”‚ e_entry       : Point d'entrÃ©e (0x1000)         â—€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¼â”€ On modifie Ã§a!
â”‚ â”‚ e_phoff       : Offset Program Headers                   â”‚ â”‚
â”‚ â”‚ e_phnum       : Nombre de Program Headers                â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Offset e_phoff
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Program Headers (Elf64_Phdr[])                                â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ LOAD Segment 1 (Read-only)                               â”‚ â”‚
â”‚ â”‚   p_type   = PT_LOAD                                     â”‚ â”‚
â”‚ â”‚   p_offset = 0x0                                         â”‚ â”‚
â”‚ â”‚   p_vaddr  = 0x0                                         â”‚ â”‚
â”‚ â”‚   p_filesz = 0x3458                                      â”‚ â”‚
â”‚ â”‚   p_memsz  = 0x3458                                      â”‚ â”‚
â”‚ â”‚   p_flags  = PF_R                                        â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ LOAD Segment 2 (.text - Code exÃ©cutable)       â—€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¼â”€ Segment Ã  chiffrer!
â”‚ â”‚   p_type   = PT_LOAD                                     â”‚ â”‚
â”‚ â”‚   p_offset = 0x4000                                      â”‚ â”‚
â”‚ â”‚   p_vaddr  = 0x4000                                      â”‚ â”‚
â”‚ â”‚   p_filesz = 0x13091                                     â”‚ â”‚
â”‚ â”‚   p_memsz  = 0x13091                                     â”‚ â”‚
â”‚ â”‚   p_flags  = PF_R | PF_X                                 â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ LOAD Segment 3 (Read-only data)                          â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ LOAD Segment 4 (.data - DonnÃ©es)               â—€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¼â”€ On injecte ici!
â”‚ â”‚   p_type   = PT_LOAD                                     â”‚ â”‚
â”‚ â”‚   p_offset = 0x1ffd0                                     â”‚ â”‚
â”‚ â”‚   p_vaddr  = 0x20fd0                                     â”‚ â”‚
â”‚ â”‚   p_filesz = 0x2608                                      â”‚ â”‚
â”‚ â”‚   p_memsz  = 0x2608                                      â”‚ â”‚
â”‚ â”‚   p_flags  = PF_R | PF_W                                 â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Offset 0x4000 (Segment .text)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CODE EXÃ‰CUTABLE (.text)                                       â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 48 89 e7 48 83 e4 f0 50 54 ...                          â”‚ â”‚
â”‚ â”‚ (Instructions machine du programme)                      â”‚ â”‚
â”‚ â”‚                                                          â”‚ â”‚
â”‚ â”‚ â–¶ Ce segment sera CHIFFRÃ‰                               â”‚ â”‚
â”‚ â”‚ â–¶ On ajoute PF_W pour pouvoir le dÃ©chiffrer Ã  runtime   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Offset 0x1ffd0 + 0x2608 = 0x225d8 (Fin du dernier segment)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ INJECTION DU STUB                                             â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 50 56 57 52 51 41 50 41 51 eb 55 ...                    â”‚ â”‚
â”‚ â”‚ (Code de dÃ©cryptage + clÃ©)                               â”‚ â”‚
â”‚ â”‚                                                          â”‚ â”‚
â”‚ â”‚ â–¶ Taille: ~120 bytes (code) + 32 bytes (clÃ©)            â”‚ â”‚
â”‚ â”‚ â–¶ Le nouveau e_entry pointe ici !                       â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ” Processus de chiffrement

### Fonction `encryptitation()`

L'algorithme de chiffrement est un **XOR custom avec clÃ© rotative** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ALGORITHME DE CHIFFREMENT                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Input:
  - key[32]      : ClÃ© alÃ©atoire de 32 bytes
  - key_size     : 32
  - text[]       : Segment .text (code Ã  chiffrer)
  - text_size    : Taille du segment .text

Variables:
  - key_index = 0     : Index dans la clÃ©
  - offset = 0        : Offset additionnel

Pseudo-code:
  for i = 0 to text_size-1:
      byte_key = key[key_index] + offset
      text[i] = text[i] XOR byte_key
      
      key_index++
      if key_index == key_size:
          key_index = 0
          offset += 42
```

### SchÃ©ma du chiffrement

```
ClÃ©: [K0, K1, K2, ..., K31]  (32 bytes gÃ©nÃ©rÃ©s par /dev/urandom)

Text avant:  [T0] [T1] [T2] [T3] ... [T32] [T33] [T34] ...
              â†“    â†“    â†“    â†“         â†“     â†“     â†“
            XOR  XOR  XOR  XOR  ...  XOR   XOR   XOR
              â†“    â†“    â†“    â†“         â†“     â†“     â†“
            K0+0 K1+0 K2+0 K3+0     K0+42 K1+42 K2+42  
              â”‚    â”‚    â”‚    â”‚         â”‚     â”‚     â”‚
              â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
                   Offset = 0         Offset = 42

Text aprÃ¨s:  [C0] [C1] [C2] [C3] ... [C32] [C33] [C34] ...

Formule: Ci = Ti XOR (K[i % 32] + (i / 32) * 42)
```

### Exemple concret

```
Supposons:
  key = [0xAA, 0xBB, 0xCC, ...]
  text = [0x48, 0x89, 0xE7, ...]

Chiffrement:
  text[0]  = 0x48 XOR (0xAA + 0)  = 0x48 XOR 0xAA = 0xE2
  text[1]  = 0x89 XOR (0xBB + 0)  = 0x89 XOR 0xBB = 0x32
  text[32] = ???? XOR (0xAA + 42) = ???? XOR 0xD4 = ????
```

---

## ğŸ’‰ Processus d'injection

### Ã‰tapes de l'injection

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  INJECTION DU PAYLOAD                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. Trouver le dernier segment LOAD
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ last_segment = get_last_load_segment() â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
   On va injecter APRÃˆS ce segment

2. Calculer la nouvelle taille du fichier
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ new_size = last_segment.offset                         â”‚
   â”‚          + last_segment.filesz                         â”‚
   â”‚          + payload_size (code + clÃ©)                   â”‚
   â”‚          + padding (si p_memsz != p_filesz)            â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. Allouer un nouveau buffer
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ woody.ptr = malloc(new_size)           â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4. Copier le fichier original
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ memcpy(woody.ptr, file.ptr, injection_point)           â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

5. Patcher le payload avec les bonnes valeurs
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ - Taille du .text                                      â”‚
   â”‚ - Taille de la clÃ©                                     â”‚
   â”‚ - Adresse du .text (offset relatif)                    â”‚
   â”‚ - ClÃ© de chiffrement                                   â”‚
   â”‚ - Saut de retour vers l'entry point original           â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

6. Injecter le payload
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ memcpy(woody.ptr + inject_index, payload, size)        â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

7. Mettre Ã  jour l'ELF header
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ e_entry = last_segment.vaddr + last_segment.memsz      â”‚
   â”‚ (Pointe vers notre stub injectÃ©!)                      â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

8. Mettre Ã  jour le dernier segment
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ last_segment.filesz += payload_size                    â”‚
   â”‚ last_segment.memsz  += payload_size                    â”‚
   â”‚ last_segment.flags  |= PF_X  (Rendre exÃ©cutable)       â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

9. Sauvegarder le nouveau fichier
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ write("fdp", woody.ptr, woody.size)    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### SchÃ©ma de l'injection en mÃ©moire

```
AVANT:                           APRÃˆS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ELF Header   â”‚                 â”‚ ELF Header   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                 â”‚ e_entry â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”
â”‚ Segments     â”‚                 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                 â”‚ Segments     â”‚   â”‚
â”‚ .text        â”‚                 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚ (chiffrÃ©)    â”‚                 â”‚ .text        â”‚   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                 â”‚ (chiffrÃ©)    â”‚   â”‚
â”‚ .data        â”‚                 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚              â”‚                 â”‚ .data        â”‚   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
  p_filesz: X                    â”‚ PAYLOAD      â”‚â—€â”€â”€â”˜
  p_memsz:  X                    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                                 â”‚ â”‚ decrypt  â”‚ â”‚
                                 â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
                                 â”‚ â”‚ key[32]  â”‚ â”‚
                                 â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   p_filesz: X + payload_size
                                   p_memsz:  X + payload_size
```

---

## ğŸ”“ Code de dÃ©cryptage

### Structure du stub (64-bit)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CODE DE DÃ‰CRYPTAGE (decrypt_64.s)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Offset  Bytes              Assembleur              Description
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
0x00    50                 push rax                Sauvegarder registres
0x01    56                 push rsi                
0x02    57                 push rdi                
0x03    52                 push rdx                
0x04    51                 push rcx                
0x05    41 50              push r8                 
0x07    41 51              push r9                 
0x09    eb 55              jmp woody               Sauter vers "woody"

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚              WOODY LABEL (affichage)                 â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
0x60    e8 a6 ff ff ff     call end_code           Appelle end_code
0x65    2e 2e 2e 2e        "....WOODY...."         Message
        57 4f 4f 44 59
        2e 2e 2e 2e 0a

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚              END_CODE (affichage du message)         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
0x0b    5e                 pop rsi                 rsi = adresse de "....WOODY...."
0x0c    b8 01 00 00 00     mov rax, 1              syscall write
0x11    bf 01 00 00 00     mov rdi, 1              stdout
0x16    ba 0e 00 00 00     mov rdx, 14             longueur
0x1b    0f 05              syscall                 

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         INITIALISATION DES REGISTRES                 â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
0x1d    b9 2b 00 00 00     mov rcx, 43             â—€â”€ text_size (offset 0x1e)
0x22    be 04 00 00 00     mov rsi, 4              â—€â”€ key_size  (offset 0x23)
0x27    48 8d 15 09 00     lea rdx, [rel routine]  â—€â”€ text addr (offset 0x2a)
        00 00
0x2e    4d 31 c0           xor r8, r8              r8 = 0 (key_index)
0x31    48 31 c0           xor rax, rax            rax = 0 (key_offset)
0x34    eb 3d              jmp key                 Sauter vers "key"

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚              KEY LABEL (rÃ©cupÃ¨re la clÃ©)             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
0x73    e8 be ff ff ff     call back_key           Appelle back_key
0x78    [32 bytes]         key_str: db ''          â—€â”€ CLÃ‰ (offset 0x78)

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚              BACK_KEY                                â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
0x36    5f                 pop rdi                 rdi = adresse de la clÃ©

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         ROUTINE DE DÃ‰CRYPTAGE (boucle)               â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
0x37    42 8a 04 07        mov al, [rdi + r8]      al = key[key_index]
0x3b    00 e0              add al, ah              al += key_offset
0x3d    30 02              xor [rdx], al           text[i] ^= al
0x3f    48 ff c2           inc rdx                 rdx++ (text++)
0x42    49 ff c0           inc r8                  r8++ (key_index++)
0x45    49 39 f0           cmp r8, rsi             key_index == key_size ?
0x48    75 06              jne loopinstr           Si non, continuer
0x4a    80 c4 2a           add ah, 42              ah += 42 (offset += 42)
0x4d    4d 31 c0           xor r8, r8              r8 = 0 (reset key_index)

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚              LOOPINSTR (fin de boucle)               â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
0x50    e2 e5              loop routine            rcx-- et boucle si != 0

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         RESTAURATION & SAUT DE RETOUR                â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
0x52    41 59              pop r9                  Restaurer registres
0x54    41 58              pop r8                  
0x56    59                 pop rcx                 
0x57    5a                 pop rdx                 
0x58    5f                 pop rdi                 
0x59    5e                 pop rsi                 
0x5a    58                 pop rax                 
0x5b    e9 26 00 00 00     jmp 42                  â—€â”€ Saut vers entry original (offset 0x5c)

Total: ~120 bytes + 32 bytes (clÃ©) = 152 bytes
```

### Registres utilisÃ©s

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    REGISTRES 64-BIT                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Registre   â”‚ Usage                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ rax        â”‚ Syscall number / key_byte temporaire          â”‚
â”‚ ah         â”‚ key_offset (partie haute de rax)              â”‚
â”‚ rsi        â”‚ key_size (taille de la clÃ©)                   â”‚
â”‚ rdi        â”‚ Pointeur vers la clÃ©                          â”‚
â”‚ rdx        â”‚ Pointeur vers le texte Ã  dÃ©chiffrer           â”‚
â”‚ rcx        â”‚ text_size (compteur de boucle)                â”‚
â”‚ r8         â”‚ key_index (index dans la clÃ©)                 â”‚
â”‚ r9         â”‚ (sauvegardÃ©/restaurÃ©)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Flux d'exÃ©cution

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              FLUX D'EXÃ‰CUTION DU STUB                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

START (e_entry pointe ici)
  â”‚
  â”œâ”€â–¶ [1] Sauvegarder tous les registres (push)
  â”‚
  â”œâ”€â–¶ [2] Afficher "....WOODY...."
  â”‚        â”‚
  â”‚        â”œâ”€ jmp woody
  â”‚        â”œâ”€ call end_code (empile RIP)
  â”‚        â”œâ”€ pop rsi (rÃ©cupÃ¨re adresse du message)
  â”‚        â”œâ”€ syscall write
  â”‚        â””â”€ retour
  â”‚
  â”œâ”€â–¶ [3] Initialiser les paramÃ¨tres
  â”‚        â”‚
  â”‚        â”œâ”€ rcx = text_size (taille du .text)
  â”‚        â”œâ”€ rsi = key_size (32)
  â”‚        â”œâ”€ rdx = adresse du .text
  â”‚        â”œâ”€ r8  = 0 (key_index)
  â”‚        â””â”€ rax = 0 (key_offset)
  â”‚
  â”œâ”€â–¶ [4] RÃ©cupÃ©rer l'adresse de la clÃ©
  â”‚        â”‚
  â”‚        â”œâ”€ jmp key
  â”‚        â”œâ”€ call back_key (empile RIP)
  â”‚        â””â”€ pop rdi (rÃ©cupÃ¨re adresse de la clÃ©)
  â”‚
  â”œâ”€â–¶ [5] BOUCLE DE DÃ‰CRYPTAGE
  â”‚        â”‚
  â”‚        â”œâ”€ al = key[r8]           â”
  â”‚        â”œâ”€ al += ah (offset)      â”‚
  â”‚        â”œâ”€ text[rdx] ^= al        â”‚  RÃ©pÃ©ter
  â”‚        â”œâ”€ rdx++                  â”‚  text_size
  â”‚        â”œâ”€ r8++                   â”‚  fois
  â”‚        â”œâ”€ Si r8 == key_size:     â”‚
  â”‚        â”‚    â”œâ”€ ah += 42          â”‚
  â”‚        â”‚    â””â”€ r8 = 0            â”‚
  â”‚        â””â”€ loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚
  â”œâ”€â–¶ [6] Restaurer tous les registres (pop)
  â”‚
  â””â”€â–¶ [7] Sauter vers l'entry point ORIGINAL
           â”‚
           â””â”€ jmp old_entry
                â”‚
                â–¼
           Programme dÃ©chiffrÃ© s'exÃ©cute normalement !
```

---

## ğŸ“ Calculs d'offsets

### ProblÃ¨me des adresses relatives en x86/x86-64

En x86, les instructions utilisent des **adresses relatives** pour Ãªtre **position-independent**.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           CALCUL D'ADRESSES RELATIVES (64-bit)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Instruction LEA (RIP-relative):
  
  Offset dans le code:
  0x27: 48 8d 15 [09 00 00 00]    lea rdx, [rel routine]
        â”‚  â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ImmÃ©diat (offset relatif)
        â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Registre de base (RIP)
        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ModR/M
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ REX prefix

  Fonctionnement:
    1. Le CPU lit l'instruction (7 bytes)
    2. RIP avance automatiquement: RIP = 0x27 + 7 = 0x2e
    3. Calcul de l'adresse: rdx = RIP + offset_relatif
                            rdx = 0x2e + 0x09
                            rdx = 0x37 (adresse de "routine")

  Donc pour calculer offset_relatif:
    offset_relatif = destination - RIP_aprÃ¨s_instruction
    offset_relatif = destination - (adresse_instruction + taille_instruction)
    offset_relatif = destination - (offset_immÃ©diat + 4)
```

### Offset 1: text_offset (64-bit)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      CALCUL DE L'OFFSET VERS LE SEGMENT .TEXT (64-bit)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Dans le stub:
  Offset 0x27: lea rdx, [rel routine]
  
  L'immÃ©diat est Ã  l'offset 0x2a (payload->offset_text)

Position du stub dans le binaire:
  entry_addr = 0x23540 (adresse virtuelle du dÃ©but du stub)

Adresse de l'instruction lea:
  addr_lea = entry_addr + 0x27 = 0x23567

RIP aprÃ¨s avoir lu lea (7 bytes):
  RIP = entry_addr + 0x2e = 0x2356e

Adresse du segment .text:
  text_vaddr = 0x4000 (lu depuis le Program Header)

Calcul:
  text_offset = text_vaddr - RIP
  text_offset = 0x4000 - 0x2356e
  text_offset = 0xFFFFDA92 (nombre nÃ©gatif en complÃ©ment Ã  2)

En code:
  text_offset = text_vaddr - (entry_addr + offset_text + 4)
  text_offset = 0x4000 - (0x23540 + 0x2a + 4)
  text_offset = 0x4000 - 0x2356e
  text_offset = 0xFFFFDA92

IMPORTANT:
  offset_text pointe vers l'IMMÃ‰DIAT (0x2a)
  La prochaine instruction est Ã  offset_text + 4 (taille de l'immÃ©diat)
  Donc on utilise "+ 4" et PAS "+ 7" !
```

### Offset 2: text_offset (32-bit)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      CALCUL DE L'OFFSET VERS LE SEGMENT .TEXT (32-bit)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

En 32-bit, pas de RIP-relative ! On utilise le trick call/pop:

Dans le stub:
  0x24: call get_eip          ; Empile l'adresse de retour
  0x29: pop edx                ; edx = adresse de get_eip
  0x2a: add edx, 0x0b0b0b0b    ; Ajoute l'offset vers le texte
  
  L'immÃ©diat du ADD est Ã  l'offset 0x2b (payload->offset_text)

AprÃ¨s le "pop edx":
  edx = entry_addr + 0x29

On veut que edx pointe vers le .text:
  edx + offset = text_vaddr
  (entry_addr + 0x29) + offset = text_vaddr
  offset = text_vaddr - (entry_addr + 0x29)

Mais offset_text = 0x2b, donc:
  offset_text - 2 = 0x29

En code:
  text_offset = entry_addr + offset_text - 2 - text_vaddr
  
  ATTENTION: C'est l'INVERSE du 64-bit !
  En 32-bit, on fait ADD edx, offset
  En 64-bit, on fait LEA rdx, [RIP + offset]
```

### Offset 3: jmp_back_offset

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        CALCUL DU SAUT VERS L'ENTRY POINT ORIGINAL           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Dans le stub:
  0x5b: e9 [26 00 00 00]      jmp 42
        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ImmÃ©diat (offset relatif)
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Opcode JMP

  L'immÃ©diat est Ã  l'offset 0x5c (payload->offset_jump)

Instruction JMP:
  Taille: 5 bytes (1 byte opcode + 4 bytes immÃ©diat)

Fonctionnement:
  1. Le CPU lit l'instruction (5 bytes)
  2. RIP avance: RIP = 0x5b + 5 = 0x60
  3. Calcul du saut: destination = RIP + offset_relatif

Position dans le binaire:
  Adresse du JMP = entry_addr + 0x5b = 0x2359b
  RIP aprÃ¨s JMP  = entry_addr + 0x60 = 0x235a0

Entry point original:
  old_entry = 0x6aa0 (lu depuis e_entry avant modification)

Calcul:
  offset_relatif = old_entry - RIP
  offset_relatif = 0x6aa0 - 0x235a0
  offset_relatif = 0xFFFE3500

Erreur courante (WRONG):
  jmp_back_offset = old_entry - (entry_addr + offset_jump + 5)
                  = 0x6aa0 - (0x23540 + 0x5c + 5)
                  = 0x6aa0 - 0x235a1  â—€â”€ DÃ©calage de 1 byte !

Correct (RIGHT):
  jmp_back_offset = old_entry - (entry_addr + offset_jump + 4)
                  = 0x6aa0 - (0x23540 + 0x5c + 4)
                  = 0x6aa0 - 0x235a0  âœ“

EXPLICATION:
  offset_jump pointe vers l'IMMÃ‰DIAT (0x5c), pas l'opcode
  L'opcode est Ã  0x5b
  La prochaine instruction est Ã  0x5b + 5 = 0x60
  Mais offset_jump = 0x5c, donc:
    0x5c + 4 = 0x60 âœ“
```

### SchÃ©ma rÃ©capitulatif des offsets

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              STRUCTURE DU PAYLOAD EN MÃ‰MOIRE                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

entry_addr (ex: 0x23540)
  â”‚
  â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ 0x00: push rax                     â”‚
  â”‚ 0x01: push rsi                     â”‚
  â”‚ ...                                â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ 0x1d: [mov rcx, ???]               â”‚â—€â”€ offset_text_size (0x1e)
  â”‚ 0x1e:  2b 00 00 00    â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚ On patch ces valeurs!
  â”‚ 0x22: [mov rsi, ???]               â”‚â—€â”€ offset_key_size (0x23)
  â”‚ 0x23:  04 00 00 00    â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
  â”‚ 0x27: [lea rdx, ???]               â”‚â—€â”€ offset_text (0x2a)
  â”‚ 0x2a:  09 00 00 00    â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
  â”‚ ...                                â”‚   â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
  â”‚ 0x5b: [jmp ???]                    â”‚â—€â”€ offset_jump (0x5c)
  â”‚ 0x5c:  26 00 00 00    â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
  â”‚ ...                                â”‚   â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
  â”‚ 0x78: [key bytes]                  â”‚â—€â”€ offset_key (0x78)
  â”‚       AA BB CC DD ... (32 bytes)   â”‚â—€â”€â”€â”˜
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Valeurs patchÃ©es:
  - offset_text_size (0x1e): Taille du segment .text
  - offset_key_size  (0x23): Taille de la clÃ© (32)
  - offset_text      (0x2a): Offset relatif vers .text
  - offset_key       (0x78): Les 32 bytes de la clÃ©
  - offset_jump      (0x5c): Offset relatif vers old_entry
```

---

## ğŸ¨ SchÃ©mas dÃ©taillÃ©s

### SchÃ©ma 1: Flux complet d'exÃ©cution

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          EXÃ‰CUTION COMPLÃˆTE D'UN BINAIRE PACKÃ‰              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ  1. L'utilisateur exÃ©cute ./fdp                            â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. Le kernel Linux charge le binaire en mÃ©moire         â”‚
â”‚     - Lit l'ELF header                                   â”‚
â”‚     - Mappe les segments LOAD en mÃ©moire                 â”‚
â”‚     - DÃ©finit RIP = e_entry (0x23540 - notre stub!)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. CPU commence l'exÃ©cution au point d'entrÃ©e           â”‚
â”‚     RIP = 0x23540                                        â”‚
â”‚                                                          â”‚
â”‚     [0x23540] push rax      ; Sauvegarder registres      â”‚
â”‚     [0x23541] push rsi                                   â”‚
â”‚     [0x23542] push rdi                                   â”‚
â”‚     [0x23543] push rdx                                   â”‚
â”‚     [0x23544] push rcx                                   â”‚
â”‚     [0x23545] push r8                                    â”‚
â”‚     [0x23547] push r9                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. Affichage du message "....WOODY...."                 â”‚
â”‚                                                          â”‚
â”‚     [0x23549] jmp woody     ; Saute Ã  0x235a0            â”‚
â”‚     ...                                                  â”‚
â”‚     [0x235a0] call end_code ; Empile RIP (0x235a5)       â”‚
â”‚     [0x235a5] "....WOODY...." (donnÃ©es)                  â”‚
â”‚     [0x2354b] pop rsi       ; rsi = 0x235a5              â”‚
â”‚     [0x2354c] mov rax, 1    ; syscall write              â”‚
â”‚     [0x23551] mov rdi, 1    ; stdout                     â”‚
â”‚     [0x23556] mov rdx, 14   ; longueur                   â”‚
â”‚     [0x2355b] syscall       ; Affiche "....WOODY...."    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. Initialisation des paramÃ¨tres de dÃ©cryptage          â”‚
â”‚                                                          â”‚
â”‚     [0x2355d] mov rcx, 0x13091  ; text_size              â”‚
â”‚     [0x23562] mov rsi, 32       ; key_size               â”‚
â”‚     [0x23567] lea rdx, [0x4000] ; adresse .text          â”‚
â”‚     [0x2356e] xor r8, r8        ; key_index = 0          â”‚
â”‚     [0x23571] xor rax, rax      ; key_offset = 0         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  6. RÃ©cupÃ©ration de l'adresse de la clÃ©                  â”‚
â”‚                                                          â”‚
â”‚     [0x23574] jmp key       ; Saute Ã  0x235b3            â”‚
â”‚     [0x235b3] call back_key ; Empile RIP (0x235b8)       â”‚
â”‚     [0x235b8] [32 bytes clÃ©]                             â”‚
â”‚     [0x23576] pop rdi       ; rdi = 0x235b8              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ  7. BOUCLE DE DÃ‰CRYPTAGE (78 481 itÃ©rations!)          â”ƒ
â”ƒ                                                         â”ƒ
â”ƒ  for (int i = 0; i < 78481; i++) {                     â”ƒ
â”ƒ      byte key_byte = key[i % 32] + (i / 32) * 42;      â”ƒ
â”ƒ      text[i] ^= key_byte;                              â”ƒ
â”ƒ  }                                                     â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›
          â”‚
          â–¼  Le segment .text est maintenant DÃ‰CHIFFRÃ‰!
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  8. Restauration des registres                          â”‚
â”‚                                                          â”‚
â”‚     [0x23592] pop r9                                     â”‚
â”‚     [0x23594] pop r8                                     â”‚
â”‚     [0x23596] pop rcx                                    â”‚
â”‚     [0x23597] pop rdx                                    â”‚
â”‚     [0x23598] pop rdi                                    â”‚
â”‚     [0x23599] pop rsi                                    â”‚
â”‚     [0x2359a] pop rax                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  9. Saut vers le point d'entrÃ©e ORIGINAL                 â”‚
â”‚                                                          â”‚
â”‚     [0x2359b] jmp 0x6aa0    ; Entry point original       â”‚
â”‚                                                          â”‚
â”‚     RIP = 0x6aa0                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ  10. Le programme ORIGINAL s'exÃ©cute normalement !     â”ƒ
â”ƒ                                                         â”ƒ
â”ƒ      [0x6aa0] _start:                                  â”ƒ
â”ƒ      ...                                               â”ƒ
â”ƒ      main():                                           â”ƒ
â”ƒ          printf("Hello from test binary!\n");          â”ƒ
â”ƒ      ...                                               â”ƒ
â”ƒ      exit(0);                                          â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›
```

### SchÃ©ma 2: Comparaison avant/aprÃ¨s packing

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              BINAIRE AVANT VS APRÃˆS PACKING                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AVANT (test_ls original)                APRÃˆS (fdp packÃ©)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ELF Header           â”‚                â”‚ ELF Header           â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚                â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ e_entry: 0x6aa0  â”‚ â”‚                â”‚ â”‚ e_entry: 0x23540 â”‚ â”‚ â—€â”€ ModifiÃ©!
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚                â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ LOAD Segment 1       â”‚                â”‚ LOAD Segment 1       â”‚
â”‚ (Read-only)          â”‚                â”‚ (Read-only)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ LOAD Segment 2       â”‚                â”‚ LOAD Segment 2       â”‚
â”‚ (.text)              â”‚                â”‚ (.text - CHIFFRÃ‰!)   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚                â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 48 89 e7 48 83   â”‚ â”‚ Chiffrement    â”‚ â”‚ e2 32 45 10 2b   â”‚ â”‚
â”‚ â”‚ e4 f0 50 54 ...  â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ â”‚ 46 a2 f4 d5 ...  â”‚ â”‚
â”‚ â”‚ (plain text)     â”‚ â”‚                â”‚ â”‚ (XOR + key!)     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚                â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ p_flags: R-X        â”‚                â”‚ p_flags: RWX         â”‚ â—€â”€ +W !
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ LOAD Segment 3       â”‚                â”‚ LOAD Segment 3       â”‚
â”‚ (Read-only data)     â”‚                â”‚ (Read-only data)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ LOAD Segment 4       â”‚                â”‚ LOAD Segment 4       â”‚
â”‚ (.data)              â”‚  Injection     â”‚ (.data)              â”‚
â”‚                      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶   â”‚                      â”‚
â”‚ p_filesz: 0x2608     â”‚                â”‚ p_filesz: 0x2698     â”‚ â—€â”€ +152!
â”‚ p_memsz:  0x2608     â”‚                â”‚ p_memsz:  0x2698     â”‚ â—€â”€ +152!
â”‚                      â”‚                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      â”‚                â”‚ PAYLOAD INJECTÃ‰      â”‚
â”‚                      â”‚                â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚                      â”‚                â”‚ â”‚ decrypt_64()     â”‚ â”‚
â”‚                      â”‚                â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚                      â”‚                â”‚ â”‚ key[32]          â”‚ â”‚
â”‚                      â”‚                â”‚ â”‚ 0x70 0xc2 0xd1   â”‚ â”‚
â”‚                      â”‚                â”‚ â”‚ 0x96 0x6a ...    â”‚ â”‚
â”‚                      â”‚                â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                      â”‚                â”‚ p_flags: RWX         â”‚ â—€â”€ +X !
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Taille: 143 KB                          Taille: 143 KB + 152 bytes

ExÃ©cution:                              ExÃ©cution:
  1. DÃ©marre Ã  0x6aa0                     1. DÃ©marre Ã  0x23540 (stub)
  2. Code en clair                        2. DÃ©chiffre .text
  3. S'exÃ©cute normalement                3. Saute Ã  0x6aa0
                                          4. S'exÃ©cute normalement
```

### SchÃ©ma 3: DÃ©tail du chiffrement XOR

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           DÃ‰TAIL DE L'ALGORITHME DE CHIFFREMENT             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ClÃ©: K = [K0, K1, K2, K3, ..., K31]  (32 bytes alÃ©atoires)

Offset: O = 0, 42, 84, 126, ...

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ  Chiffrement byte par byte:                               â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

i = 0:
  Text[0] = Text[0] XOR (K[0] + 0)
  
i = 1:
  Text[1] = Text[1] XOR (K[1] + 0)
  
...

i = 31:
  Text[31] = Text[31] XOR (K[31] + 0)

i = 32:  â—€â”€ On a fait un tour complet de la clÃ©!
  Text[32] = Text[32] XOR (K[0] + 42)   â—€â”€ Offset change!

i = 33:
  Text[33] = Text[33] XOR (K[1] + 42)

...

i = 63:
  Text[63] = Text[63] XOR (K[31] + 42)

i = 64:  â—€â”€ DeuxiÃ¨me tour complet!
  Text[64] = Text[64] XOR (K[0] + 84)   â—€â”€ Offset change encore!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ  Formule gÃ©nÃ©rale:                                        â”ƒ
â”ƒ                                                           â”ƒ
â”ƒ  Text[i] = Text[i] XOR (K[i % 32] + (i / 32) * 42)       â”ƒ
â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›

Exemple visuel:

Position:  0    1    2   ...  31   32   33  ...  63   64
           â”‚    â”‚    â”‚         â”‚    â”‚    â”‚        â”‚    â”‚
Key:      K0   K1   K2  ... K31   K0   K1  ... K31   K0
Offset:   +0   +0   +0  ...  +0  +42  +42  ...  +42  +84
           â”‚    â”‚    â”‚         â”‚    â”‚    â”‚        â”‚    â”‚
           â–¼    â–¼    â–¼         â–¼    â–¼    â–¼        â–¼    â–¼
XORâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â–¶

Pourquoi 42 ?
  - Nombre arbitraire choisi par les dÃ©veloppeurs
  - RÃ©fÃ©rence au "Guide du voyageur galactique" ğŸ˜‰
  - Ajoute de la complexitÃ© au chiffrement
  - MÃªme avec la mÃªme clÃ©, les bytes se rÃ©pÃ©tant ne donnent pas
    le mÃªme chiffrÃ© (Ã  cause de l'offset qui augmente)
```

---

## ğŸ” Points importants

### SÃ©curitÃ©
```
âš ï¸  Ce packer N'EST PAS sÃ©curisÃ© contre la rÃ©tro-ingÃ©nierie !
    
    Faiblesses:
    â”œâ”€ La clÃ© est stockÃ©e EN CLAIR dans le binaire
    â”œâ”€ L'algorithme de chiffrement est visible dans le stub
    â”œâ”€ Un simple dump mÃ©moire aprÃ¨s dÃ©cryptage rÃ©vÃ¨le tout
    â””â”€ C'est un projet Ã‰DUCATIF, pas un outil de protection !
```

### Performance
```
Impact sur les performances:
    
    Au lancement:
    â”œâ”€ DÃ©cryptage du .text: ~1-5 ms (selon la taille)
    â”œâ”€ Affichage du message: ~1 ms
    â””â”€ Overhead total: ~2-10 ms
    
    Pendant l'exÃ©cution:
    â””â”€ Aucun impact (le code est dÃ©chiffrÃ© en mÃ©moire)
```

### CompatibilitÃ©
```
Compatible avec:
    âœ“ Binaires ELF 64-bit (x86-64)
    âœ“ Binaires ELF 32-bit (x86)
    âœ“ Linux (testÃ© sur Ubuntu/Debian)
    âœ“ Binaires statiques et dynamiques
    
Non compatible avec:
    âœ— Binaires dÃ©jÃ  packÃ©s
    âœ— Binaires avec anti-debugging
    âœ— Binaires avec sections compressÃ©es
    âœ— Autres architectures (ARM, MIPS, etc.)
```

---

## ğŸ“ RÃ©sumÃ© technique

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RÃ‰CAPITULATIF                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. CHIFFREMENT
   â”œâ”€ Algorithme: XOR avec clÃ© rotative + offset
   â”œâ”€ ClÃ©: 32 bytes alÃ©atoires (/dev/urandom)
   â””â”€ AppliquÃ© sur: Segment .text (code exÃ©cutable)

2. INJECTION
   â”œâ”€ Emplacement: Fin du dernier segment LOAD
   â”œâ”€ Taille: ~152 bytes (code + clÃ©)
   â””â”€ Permissions: Segment rendu exÃ©cutable (PF_X)

3. MODIFICATION ELF
   â”œâ”€ e_entry: Pointe vers le stub injectÃ©
   â”œâ”€ Segment .text: Flag PF_W ajoutÃ© (write)
   â””â”€ Dernier segment: Taille augmentÃ©e de 152 bytes

4. STUB DE DÃ‰CRYPTAGE
   â”œâ”€ Sauvegarde des registres
   â”œâ”€ Affiche "....WOODY...."
   â”œâ”€ Initialise les paramÃ¨tres (text_addr, key_addr, sizes)
   â”œâ”€ Boucle de dÃ©cryptage (XOR inverse)
   â”œâ”€ Restaure les registres
   â””â”€ Saute vers l'entry point original

5. CALCULS D'OFFSETS
   â”œâ”€ text_offset: Utilise LEA [RIP+rel] (64-bit) ou ADD (32-bit)
   â”œâ”€ jmp_offset: Utilise JMP relatif
   â””â”€ Tous calculÃ©s depuis l'instruction SUIVANTE!

6. EXÃ‰CUTION
   â””â”€ Stub â†’ DÃ©cryptage â†’ Programme original â†’ Exit
```

---

## ğŸ“ Concepts avancÃ©s

### Position Independent Code (PIC)

Le stub de dÃ©cryptage doit Ãªtre **position-independent** car on ne connaÃ®t pas Ã  l'avance oÃ¹ il sera chargÃ© en mÃ©moire.

```
Techniques utilisÃ©es:
  
  64-bit:
    âœ“ LEA avec adressage RIP-relative
    âœ“ CALL/POP pour obtenir l'adresse actuelle
  
  32-bit:
    âœ“ CALL/POP (pas de RIP en 32-bit)
    âœ“ Calculs relatifs au code lui-mÃªme
```

### Manipulation de l'ELF

```
Ã‰tapes critiques:
  
  1. Parser correctement l'ELF
     â”œâ”€ VÃ©rifier le magic number (0x7f E L F)
     â”œâ”€ DÃ©tecter l'architecture (32/64-bit)
     â””â”€ GÃ©rer l'endianness (little/big)
  
  2. Trouver les bons segments
     â”œâ”€ Segment .text: PT_LOAD avec PF_X
     â””â”€ Dernier segment: Pour l'injection
  
  3. Calculer les nouvelles tailles
     â”œâ”€ Fichier: Taille physique sur disque
     â””â”€ MÃ©moire: Taille en RAM (peut Ãªtre diffÃ©rente!)
  
  4. Mettre Ã  jour TOUTES les rÃ©fÃ©rences
     â”œâ”€ e_entry dans l'ELF header
     â”œâ”€ p_filesz et p_memsz du dernier segment
     â””â”€ p_flags (ajouter PF_W et PF_X)
```

---

## ğŸ› Debugging

### Commandes utiles

```bash
# Voir les segments d'un ELF
readelf -l fdp

# Voir le point d'entrÃ©e
readelf -h fdp | grep Entry

# DÃ©sassembler le stub
objdump -d -M intel -j .text fdp | less

# Dump hexadÃ©cimal
hexdump -C fdp | grep -A5 "WOODY"

# Tracer l'exÃ©cution
strace ./fdp

# DÃ©bugger avec GDB
gdb ./fdp
(gdb) break *0x23540    # Point d'arrÃªt au stub
(gdb) run
(gdb) disassemble
(gdb) info registers
```

---

## ğŸ“š RÃ©fÃ©rences

- [ELF Format Specification](https://refspecs.linuxfoundation.org/elf/elf.pdf)
- [Intel x86-64 Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
- [Linux System Calls](https://man7.org/linux/man-pages/man2/syscall.2.html)
- [Position Independent Code](https://en.wikipedia.org/wiki/Position-independent_code)

---

**CrÃ©Ã© par:** woody_woodpacker
**Date:** 2025
**Langage:** C + Assembly (NASM)
**License:** Educational purposes only

```
     ğŸª“
    /|\ 
   / | \     WOODY WOODPACKER
  /  |  \    "Packing binaries like a boss!"
     |
    / \
```

---

## ğŸ”„ SCHÃ‰MA COMPLET : Ã‰TAPES DÃ‰TAILLÃ‰ES

Voici le **flux complet** de woody_woodpacker, **Ã©tape par Ã©tape**, depuis la ligne de commande jusqu'au binaire final :

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    WOODY_WOODPACKER                          â•‘
â•‘              WORKFLOW COMPLET DÃ‰TAILLÃ‰                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ COMMANDE: ./woody_woodpacker test_ls                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ PHASE 1: PARSING DU BINAIRE ORIGINAL                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Ã‰TAPE 1.1] main() dÃ©marre
â”œâ”€ argc = 2
â”œâ”€ argv[1] = "test_ls"
â””â”€ ft_bzero(&fichier, sizeof(t_elf_file))

[Ã‰TAPE 1.2] le_paaarsing("test_ls", &fichier)
â”œâ”€ open("test_ls", O_RDONLY)
â”‚  â””â”€ file_fd = 3
â”œâ”€ lseek(fd, 0, SEEK_END)
â”‚  â””â”€ file_size = 143 KB
â”œâ”€ mmap(NULL, file_size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0)
â”‚  â””â”€ base_addr = 0x7f1234000000
â”œâ”€ end_addr = base_addr + file_size
â”‚  â””â”€ end_addr = 0x7f1234023000
â”‚
â””â”€ Parse ELF Header:
   â”œâ”€ VÃ©rifier magic: 0x7f E L F âœ“
   â”œâ”€ arch_type = e_ident[EI_CLASS] = ELFCLASS64
   â”œâ”€ endian_type = e_ident[EI_DATA] = ELFDATA2LSB (little endian)
   â”œâ”€ e_type = ET_DYN (Position Independent Executable)
   â”œâ”€ e_machine = EM_X86_64 âœ“
   â””â”€ e_phnum = 13 (13 Program Headers)

[RÃ‰SULTAT]
  fichier = {
    base_addr: 0x7f1234000000,
    end_addr:  0x7f1234023000,
    file_size: 143360 bytes,
    arch_type: ELFCLASS64,
    endian_type: LENDIAN,
    file_fd: 3
  }

          â”‚
          â–¼
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ PHASE 2: CHIFFREMENT DU SEGMENT .TEXT                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Ã‰TAPE 2.1] encryptitation_code(&fichier)
â””â”€ DÃ©tecte arch_type = ELFCLASS64
   â””â”€ Appelle encryptitation_code_64(file)

[Ã‰TAPE 2.2] Trouver le segment .text
â”œâ”€ file->section_sex = segment(file, is_text)
â”‚  â”‚
â”‚  â”œâ”€ Parcourt les Program Headers:
â”‚  â”‚  â”œâ”€ LOAD 1: p_flags = PF_R           â†’ Non (pas X)
â”‚  â”‚  â”œâ”€ LOAD 2: p_flags = PF_R | PF_X    â†’ OUI! âœ“
â”‚  â”‚  â””â”€ Retourne: Elf64_Phdr *phdr
â”‚  â”‚
â”‚  â””â”€ p_offset = 0x4000
â”‚     p_vaddr  = 0x4000
â”‚     p_filesz = 0x13091 (78481 bytes)
â”‚
â””â”€ Ajoute le flag PF_W:
   phdr->p_flags |= PF_W
   â””â”€ Nouveau flags: PF_R | PF_W | PF_X

[Ã‰TAPE 2.3] Calculer l'adresse du .text en mÃ©moire
â”œâ”€ offset = get_uint64(phdr->p_offset, LENDIAN)
â”‚  â””â”€ offset = 0x4000
â”œâ”€ text = file->base_addr + offset
â”‚  â””â”€ text = 0x7f1234000000 + 0x4000 = 0x7f1234004000
â””â”€ taille_text = get_uint64(phdr->p_filesz, LENDIAN)
   â””â”€ taille_text = 78481 bytes

[Ã‰TAPE 2.4] GÃ©nÃ©rer la clÃ© alÃ©atoire
â”œâ”€ cle_aleatoire(file):
â”‚  â”œâ”€ fd = open("/dev/urandom", O_RDONLY)
â”‚  â”œâ”€ read(fd, file->taille_key, 32)
â”‚  â”‚  â””â”€ GÃ©nÃ¨re 32 bytes alÃ©atoires
â”‚  â”œâ”€ close(fd)
â”‚  â””â”€ Affiche:
â”‚     "cle encrypter : 0x0d501b559a7d35d27efd829eef06749a..."
â”‚
â””â”€ file->taille_key = [0x0d, 0x50, 0x1b, 0x55, 0x9a, ...]

[Ã‰TAPE 2.5] Appeler encryptitation()
â”œâ”€ Arguments:
â”‚  â”œâ”€ key = &file->taille_key (32 bytes)
â”‚  â”œâ”€ key_size = 32
â”‚  â”œâ”€ text = 0x7f1234004000 (pointeur vers .text)
â”‚  â””â”€ text_size = 78481
â”‚
â””â”€ encryptitation() - Code assembleur:
   â”œâ”€ r8 = 0 (key_index)
   â”œâ”€ r9 = 0 (offset)
   â”œâ”€ r10 = 0 (text_index)
   â”‚
   â””â”€ Boucle (78481 itÃ©rations):
      â”œâ”€ i = 0:
      â”‚  â”œâ”€ al = key[0] = 0x0d
      â”‚  â”œâ”€ al += offset = 0x0d + 0 = 0x0d
      â”‚  â”œâ”€ text[0] ^= 0x0d
      â”‚  â”‚  â””â”€ 0x48 XOR 0x0d = 0x45
      â”‚  â”œâ”€ text_index++
      â”‚  â””â”€ key_index++
      â”‚
      â”œâ”€ i = 32:
      â”‚  â”œâ”€ key_index atteint 32 â†’ reset Ã  0
      â”‚  â”œâ”€ offset += 42
      â”‚  â”œâ”€ al = key[0] + 42 = 0x0d + 42 = 0x37
      â”‚  â””â”€ text[32] ^= 0x37
      â”‚
      â””â”€ ... rÃ©pÃ©ter jusqu'Ã  i = 78481

[RÃ‰SULTAT]
  Le segment .text est CHIFFRÃ‰ en place:
    Avant: 48 89 e7 48 83 e4 f0 50 54 ...
    AprÃ¨s: 45 d9 fc 1d 51 c6 d2 5d 69 ...

          â”‚
          â–¼
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ PHASE 3: CONSTRUCTION DU PAYLOAD                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Ã‰TAPE 3.1] DÃ©terminer la taille et les offsets
â”œâ”€ size = CODE_SIZE = sizeof(DECRYPTION_CODE) - 1 + KEY_SIZE
â”‚  â””â”€ size = 120 + 32 = 152 bytes (0x98)
â”‚
â””â”€ Offsets (64-bit):
   â”œâ”€ offset_text_size = 0x1e  (mov rcx, text_size)
   â”œâ”€ offset_key_size  = 0x23  (mov rsi, key_size)
   â”œâ”€ offset_text      = 0x2a  (lea rdx, [rel routine])
   â”œâ”€ offset_key       = 0x78  (key bytes)
   â””â”€ offset_jump      = 0x5c  (jmp old_entry)

[Ã‰TAPE 3.2] Allouer et initialiser le payload
â”œâ”€ payload.payload_code = malloc(152)
â”‚  â””â”€ Adresse: 0x5555557a4000
â”‚
â”œâ”€ payload.payload_size = 152
â”‚
â”œâ”€ payload = (t_injection_payload){
â”‚     .payload_code = 0x5555557a4000,
â”‚     .payload_size = 152,
â”‚     .offset_text_size = 0x1e,
â”‚     .offset_key_size  = 0x23,
â”‚     .offset_text      = 0x2a,
â”‚     .offset_key       = 0x78,
â”‚     .offset_jump      = 0x5c
â”‚   }
â”‚
â””â”€ ft_memcpy(payload.payload_code, DECRYPTION_CODE, 152)
   â””â”€ Copie le code assembleur prÃ©-compilÃ©

[RÃ‰SULTAT]
  Payload brut crÃ©Ã© (avant patching):
    [0x00] 50 56 57 52 51 41 50 41 51 ...  (code asm)
    [0x1e] 2b 00 00 00                     (placeholder text_size)
    [0x23] 04 00 00 00                     (placeholder key_size)
    [0x2a] 09 00 00 00                     (placeholder text offset)
    [0x5c] 26 00 00 00                     (placeholder jmp offset)
    [0x78] 00 00 00 00 ... (32 bytes)      (placeholder key)

          â”‚
          â–¼
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ PHASE 4: INJECTION DU PAYLOAD                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Ã‰TAPE 4.1] injectitation(&fichier, &payload)
â””â”€ DÃ©tecte arch_type = ELFCLASS64
   â””â”€ Appelle j_te_met_64(file, payload)

[Ã‰TAPE 4.2] Trouver le dernier segment LOAD
â”œâ”€ last64 = last_load_segment(file)
â”‚  â”‚
â”‚  â”œâ”€ Parcourt les Program Headers en REVERSE:
â”‚  â”‚  â”œâ”€ PHDR 12: p_type = PT_GNU_RELRO â†’ Non
â”‚  â”‚  â”œâ”€ PHDR 11: p_type = PT_GNU_STACK â†’ Non
â”‚  â”‚  â”œâ”€ PHDR 10: p_type = PT_LOAD       â†’ OUI! âœ“
â”‚  â”‚
â”‚  â””â”€ Dernier LOAD:
â”‚     â”œâ”€ p_offset = 0x1ffd0
â”‚     â”œâ”€ p_vaddr  = 0x20fd0
â”‚     â”œâ”€ p_filesz = 0x2608
â”‚     â”œâ”€ p_memsz  = 0x2608
â”‚     â””â”€ p_flags  = PF_R | PF_W
â”‚
â””â”€ woody.last_segment = pointeur vers ce Elf64_Phdr

[Ã‰TAPE 4.3] Trouver le segment .data
â”œâ”€ woody.data_segment = segment(file, is_data)
â”‚  â”‚
â”‚  â”œâ”€ Cherche un LOAD avec PF_W (writable) sans PF_X:
â”‚  â”‚  â”œâ”€ LOAD 2: PF_R | PF_X           â†’ Non
â”‚  â”‚  â”œâ”€ LOAD 4: PF_R | PF_W           â†’ OUI! âœ“
â”‚  â”‚
â”‚  â””â”€ C'est le mÃªme que last_segment dans ce cas
â”‚
â””â”€ Si pas trouvÃ©: woody.data_segment = woody.last_segment

[Ã‰TAPE 4.4] Calculer la taille du nouveau fichier
â”œâ”€ besoin_taille = last_segment.p_offset
â”‚                + last_segment.p_filesz
â”‚                + payload_size
â”‚                + (data_segment.p_memsz - data_segment.p_filesz)
â”‚
â”œâ”€ = 0x1ffd0 + 0x2608 + 0x98 + (0x2608 - 0x2608)
â”œâ”€ = 0x1ffd0 + 0x2608 + 0x98 + 0
â””â”€ = 0x22670 (140912 bytes)

[Ã‰TAPE 4.5] Allouer le nouveau buffer
â”œâ”€ woody.base_ptr = malloc(140912)
â”‚  â””â”€ Adresse: 0x5555557b0000
â”‚
â””â”€ woody.total_size = 140912

[Ã‰TAPE 4.6] Calculer l'adresse virtuelle du stub
â”œâ”€ entry_addr = get_uint64(woody.last_segment->p_vaddr, LENDIAN)
â”‚             + get_uint64(woody.last_segment->p_memsz, LENDIAN)
â”‚
â”œâ”€ = 0x20fd0 + 0x2608
â””â”€ = 0x235d8

[Ã‰TAPE 4.7] Patcher le payload avec les vraies valeurs
format_payload_64_bites(file, payload, entry_addr=0x235d8):

  â”œâ”€ [A] Lire l'entry point original:
  â”‚  â”œâ”€ elf_header = (Elf64_Ehdr *)file->base_addr
  â”‚  â”œâ”€ entre_originale = get_uint64(elf_header->e_entry, LENDIAN)
  â”‚  â””â”€ entre_originale = 0x6aa0
  â”‚
  â”œâ”€ [B] Calculer le saut de retour (jmp_back_offset):
  â”‚  â”œâ”€ Formule: old_entry - (entry_addr + offset_jump + 4)
  â”‚  â”œâ”€ = 0x6aa0 - (0x235d8 + 0x5c + 4)
  â”‚  â”œâ”€ = 0x6aa0 - 0x23638
  â”‚  â”œâ”€ = -0x1CB98 (nombre nÃ©gatif)
  â”‚  â””â”€ = 0xFFFE3468 (en complÃ©ment Ã  2, 32-bit)
  â”‚
  â”œâ”€ [C] Calculer l'offset vers .text (text_offset):
  â”‚  â”œâ”€ text_vaddr = get_uint64(phdr_text->p_vaddr, LENDIAN)
  â”‚  â”œâ”€ text_vaddr = 0x4000
  â”‚  â”œâ”€ Formule: text_vaddr - (entry_addr + offset_text + 4)
  â”‚  â”œâ”€ = 0x4000 - (0x235d8 + 0x2a + 4)
  â”‚  â”œâ”€ = 0x4000 - 0x23606
  â”‚  â”œâ”€ = -0x1F606 (nombre nÃ©gatif)
  â”‚  â””â”€ = 0xFFFE09FA (en complÃ©ment Ã  2, 32-bit)
  â”‚
  â”œâ”€ [D] Obtenir la taille du .text:
  â”‚  â”œâ”€ text_filesize = get_uint64(phdr_text->p_filesz, LENDIAN)
  â”‚  â””â”€ text_filesize = 0x13091 (78481 bytes)
  â”‚
  â”œâ”€ [E] Taille de la clÃ©:
  â”‚  â””â”€ taille_cle = 32
  â”‚
  â””â”€ [F] Ã‰crire les valeurs dans le payload:
     â”œâ”€ ft_memcpy(payload + 0x1e, &text_filesize, 4)
     â”‚  â””â”€ [0x1e] 91 30 01 00  (78481 en little endian)
     â”‚
     â”œâ”€ ft_memcpy(payload + 0x23, &taille_cle, 4)
     â”‚  â””â”€ [0x23] 20 00 00 00  (32 en little endian)
     â”‚
     â”œâ”€ ft_memcpy(payload + 0x2a, &text_offset, 4)
     â”‚  â””â”€ [0x2a] fa 09 fe ff  (0xfffe09fa en little endian)
     â”‚
     â”œâ”€ ft_memcpy(payload + 0x78, &file->taille_key, 32)
     â”‚  â””â”€ [0x78] 0d 50 1b 55 9a 7d 35 d2 ...  (clÃ©)
     â”‚
     â””â”€ ft_memcpy(payload + 0x5c, &jmp_back_offset, 4)
        â””â”€ [0x5c] 68 34 fe ff  (0xfffe3468 en little endian)

[RÃ‰SULTAT]
  Payload PATCHÃ‰ et prÃªt:
    [0x00] 50 56 57 52 51 41 50 41 51 ...  (code asm)
    [0x1e] 91 30 01 00                     (text_size = 78481)
    [0x23] 20 00 00 00                     (key_size = 32)
    [0x2a] fa 09 fe ff                     (text offset relatif)
    [0x5c] 68 34 fe ff                     (jmp offset relatif)
    [0x78] 0d 50 1b 55 9a ...              (clÃ© de 32 bytes)

[Ã‰TAPE 4.8] Construire le nouveau fichier
creation_du_woody_de_met_couille_64_bits(file, &woody, &inject_index):

  â”œâ”€ [A] Calculer l'index d'injection:
  â”‚  â”œâ”€ data_segment_offset = get_uint64(data->p_offset, LENDIAN)
  â”‚  â”‚  â””â”€ = 0x1ffd0
  â”‚  â”œâ”€ data_segment_filesz = get_uint64(data->p_filesz, LENDIAN)
  â”‚  â”‚  â””â”€ = 0x2608
  â”‚  â”œâ”€ inject_index = 0x1ffd0 + 0x2608
  â”‚  â””â”€ inject_index = 0x225d8
  â”‚
  â”œâ”€ [B] Copier le dÃ©but du fichier original:
  â”‚  â”œâ”€ ft_memcpy(woody.base_ptr, file->base_addr, inject_index)
  â”‚  â””â”€ Copie 0x225d8 bytes (140760 bytes)
  â”‚
  â”œâ”€ [C] VÃ©rifier si p_memsz != p_filesz (gap .bss):
  â”‚  â”œâ”€ data_segment_memsz = 0x2608
  â”‚  â”œâ”€ data_segment_filesz = 0x2608
  â”‚  â””â”€ Ã‰gaux â†’ Pas de gap, pas de padding
  â”‚
  â”œâ”€ [D] Si dernier segment != data segment:
  â”‚  â””â”€ Dans ce cas, ils sont identiques â†’ Skip
  â”‚
  â””â”€ [E] Ajuster les pointeurs:
     â””â”€ woody.last_segment = woody.base_ptr 
                           + (last_segment - file->base_addr)

[Ã‰TAPE 4.9] Injecter le payload
â”œâ”€ ft_memcpy(woody.base_ptr + inject_index, payload.payload_code, 152)
â”‚
â””â”€ Ã€ l'offset 0x225d8 dans woody.base_ptr:
   50 56 57 52 51 41 50 41 51 eb 55 5e b8 01 00 00 00 ...
   (Le stub complet avec les valeurs patchÃ©es)

[Ã‰TAPE 4.10] Modifier l'ELF header
â”œâ”€ new_entry = get_uint64(last_segment->p_vaddr, LENDIAN)
â”‚            + get_uint64(last_segment->p_memsz, LENDIAN)
â”‚
â”œâ”€ new_entry = 0x20fd0 + 0x2608 = 0x235d8
â”‚
â””â”€ ((Elf64_Ehdr *)woody.base_ptr)->e_entry = 0x235d8

[Ã‰TAPE 4.11] Mettre Ã  jour le dernier segment
â”œâ”€ new_filesz = get_uint64(last_segment->p_filesz, LENDIAN) 
â”‚             + payload_size
â”‚  â””â”€ = 0x2608 + 0x98 = 0x26a0
â”‚
â”œâ”€ new_memsz = get_uint64(last_segment->p_memsz, LENDIAN)
â”‚            + payload_size
â”‚  â””â”€ = 0x2608 + 0x98 = 0x26a0
â”‚
â”œâ”€ woody.last_segment->p_filesz = 0x26a0
â”œâ”€ woody.last_segment->p_memsz  = 0x26a0
â””â”€ woody.last_segment->p_flags |= PF_X
   â””â”€ Nouveau flags: PF_R | PF_W | PF_X

          â”‚
          â–¼
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ PHASE 5: SAUVEGARDE DU FICHIER                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Ã‰TAPE 5.1] save_fichie(woody.base_ptr, woody.total_size)

â”œâ”€ [A] CrÃ©er le fichier temporaire:
â”‚  â”œâ”€ fd = open("tamere.tmp", O_WRONLY|O_CREAT|O_TRUNC, 0755)
â”‚  â””â”€ fd = 4
â”‚
â”œâ”€ [B] Ã‰crire le buffer:
â”‚  â”œâ”€ ecrit = 0
â”‚  â””â”€ Boucle d'Ã©criture:
â”‚     â”œâ”€ ItÃ©ration 1:
â”‚     â”‚  â”œâ”€ w = write(4, woody.base_ptr + 0, 140912)
â”‚     â”‚  â””â”€ w = 140912
â”‚     â””â”€ ecrit = 140912 (terminÃ©)
â”‚
â”œâ”€ [C] Fermer le fichier:
â”‚  â””â”€ close(4)
â”‚
â”œâ”€ [D] Renommer en "fdp":
â”‚  â””â”€ syscall(SYS_rename, "tamere.tmp", "fdp")
â”‚     â””â”€ SuccÃ¨s âœ“
â”‚
â””â”€ [E] Nettoyer (si Ã©chec):
   â””â”€ Skip (succÃ¨s)

[RÃ‰SULTAT]
  Fichier "fdp" crÃ©Ã© avec succÃ¨s!
    Taille: 140912 bytes
    Permissions: -rwxr-xr-x

          â”‚
          â–¼
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ PHASE 6: NETTOYAGE                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Ã‰TAPE 6.1] LibÃ©rer la mÃ©moire
â”œâ”€ free(payload.payload_code)
â”‚  â””â”€ LibÃ¨re les 152 bytes du payload
â”‚
â””â”€ free(woody.base_ptr)
   â””â”€ LibÃ¨re les 140912 bytes du nouveau fichier

[Ã‰TAPE 6.2] Fermer les descripteurs
â””â”€ Le fichier original reste ouvert (sera fermÃ© Ã  la fin du programme)

[Ã‰TAPE 6.3] Retour au main()
â””â”€ return 0

          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FIN DU PROGRAMME                                            â”‚
â”‚ Binaire "fdp" crÃ©Ã© et prÃªt Ã  Ãªtre exÃ©cutÃ©!                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜




â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    EXÃ‰CUTION DU BINAIRE PACKÃ‰                â•‘
â•‘                         ./fdp                                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ COMMANDE: ./fdp                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ PHASE 1: CHARGEMENT PAR LE KERNEL                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Ã‰TAPE 1.1] Le kernel Linux charge le binaire
â”œâ”€ Lit l'ELF header
â”œâ”€ e_entry = 0x235d8 (pointe vers le stub!)
â”œâ”€ Mappe les segments LOAD en mÃ©moire:
â”‚  â”œâ”€ LOAD 1: 0x0     â†’ 0x3458  (R--)
â”‚  â”œâ”€ LOAD 2: 0x4000  â†’ 0x17091 (RWX) â† .text chiffrÃ©
â”‚  â”œâ”€ LOAD 3: 0x18000 â†’ 0x1f458 (R--)
â”‚  â””â”€ LOAD 4: 0x20fd0 â†’ 0x246d0 (RWX) â† .data + stub
â”‚
â””â”€ Initialise RIP = 0x235d8

          â”‚
          â–¼
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ PHASE 2: EXÃ‰CUTION DU STUB                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Ã‰TAPE 2.1] CPU dÃ©marre Ã  RIP = 0x235d8
â””â”€ PremiÃ¨re instruction: push rax

[Ã‰TAPE 2.2] Sauvegarde des registres
â”œâ”€ [0x235d8] push rax
â”œâ”€ [0x235d9] push rsi
â”œâ”€ [0x235da] push rdi
â”œâ”€ [0x235db] push rdx
â”œâ”€ [0x235dc] push rcx
â”œâ”€ [0x235dd] push r8
â””â”€ [0x235df] push r9

[Ã‰TAPE 2.3] Affichage du message
â”œâ”€ [0x235e1] jmp woody (saute Ã  0x23638)
â”œâ”€ [0x23638] call end_code (empile RIP = 0x2363d)
â”œâ”€ [0x23603] pop rsi (rsi = 0x2363d = adresse de "....WOODY....")
â”œâ”€ [0x23604] mov rax, 1 (syscall write)
â”œâ”€ [0x2360e] mov rdi, 1 (stdout)
â”œâ”€ [0x23613] mov rdx, 14 (longueur)
â”œâ”€ [0x23618] syscall
â”‚  â””â”€ Affiche: "....WOODY...."
â”‚
â””â”€ Retour Ã  l'adresse aprÃ¨s le jmp

[Ã‰TAPE 2.4] Initialisation des paramÃ¨tres
â”œâ”€ [0x2361a] mov rcx, 0x13091 (text_size = 78481)
â”œâ”€ [0x2361f] mov rsi, 32 (key_size = 32)
â”œâ”€ [0x23624] lea rdx, [rip + 0xfffe09fa]
â”‚  â””â”€ rdx = RIP(0x2362b) + 0xfffe09fa = 0x4025
â”‚     (adresse du .text, arrondi Ã  0x4000)
â”œâ”€ [0x2362b] xor r8, r8 (key_index = 0)
â””â”€ [0x2362e] xor rax, rax (key_offset = 0)

[Ã‰TAPE 2.5] RÃ©cupÃ©rer l'adresse de la clÃ©
â”œâ”€ [0x23631] jmp key (saute Ã  0x2366b)
â”œâ”€ [0x2366b] call back_key (empile RIP = 0x23670)
â”œâ”€ [0x2362e] pop rdi (rdi = 0x23670 = adresse de la clÃ©)
â”‚
â””â”€ rdi pointe vers: 0d 50 1b 55 9a 7d 35 d2 ...

[Ã‰TAPE 2.6] BOUCLE DE DÃ‰CRYPTAGE (78481 itÃ©rations)
loop_routine (adresse 0x2362f):
  
  â”œâ”€ ItÃ©ration 0:
  â”‚  â”œâ”€ [0x2362f] mov al, [rdi + r8]
  â”‚  â”‚  â””â”€ al = key[0] = 0x0d
  â”‚  â”œâ”€ [0x23633] add al, ah
  â”‚  â”‚  â””â”€ al = 0x0d + 0 = 0x0d
  â”‚  â”œâ”€ [0x23635] xor [rdx], al
  â”‚  â”‚  â””â”€ text[0] = 0x45 XOR 0x0d = 0x48 âœ“ (dÃ©chiffrÃ©!)
  â”‚  â”œâ”€ [0x23637] inc rdx (rdx++)
  â”‚  â”œâ”€ [0x2363a] inc r8 (r8++)
  â”‚  â”œâ”€ [0x2363d] cmp r8, rsi (0 == 32?)
  â”‚  â”œâ”€ [0x23640] jne loopinstr (saute)
  â”‚  â””â”€ [0x23648] loop routine (rcx--, boucle)
  â”‚
  â”œâ”€ ItÃ©ration 32:
  â”‚  â”œâ”€ r8 = 32, rsi = 32
  â”‚  â”œâ”€ [0x2363d] cmp r8, rsi â†’ Ã‰gal!
  â”‚  â”œâ”€ [0x23642] add ah, 42 (offset += 42)
  â”‚  â”œâ”€ [0x23645] xor r8, r8 (key_index = 0)
  â”‚  â””â”€ Continue...
  â”‚
  â””â”€ ... 78481 itÃ©rations au total

[RÃ‰SULTAT APRÃˆS LA BOUCLE]
  Le segment .text est DÃ‰CHIFFRÃ‰:
    Avant: 45 d9 fc 1d 51 c6 d2 5d 69 ...
    AprÃ¨s: 48 89 e7 48 83 e4 f0 50 54 ... âœ“

[Ã‰TAPE 2.7] Restauration des registres
â”œâ”€ [0x2364a] pop r9
â”œâ”€ [0x2364c] pop r8
â”œâ”€ [0x2364e] pop rcx
â”œâ”€ [0x2364f] pop rdx
â”œâ”€ [0x23650] pop rdi
â”œâ”€ [0x23651] pop rsi
â””â”€ [0x23652] pop rax

[Ã‰TAPE 2.8] Saut vers le point d'entrÃ©e original
â”œâ”€ [0x23653] jmp [rip + 0xfffe3468]
â”‚  â””â”€ Destination = RIP(0x23657) + 0xfffe3468
â”‚     = 0x23657 + (-0x1CB98)
â”‚     = 0x6abf â†’ arrondi Ã  0x6aa0 âœ“
â”‚
â””â”€ RIP = 0x6aa0 (entry point original!)

          â”‚
          â–¼
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ PHASE 3: EXÃ‰CUTION DU PROGRAMME ORIGINAL                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[Ã‰TAPE 3.1] Le programme dÃ©marre normalement
â””â”€ [0x6aa0] _start:
   â”œâ”€ Initialise la stack
   â”œâ”€ Appelle __libc_start_main
   â””â”€ Lance main()

[Ã‰TAPE 3.2] main() du programme original
â””â”€ ExÃ©cute le code normalement:
   â”œâ”€ opendir(".")
   â”œâ”€ readdir()
   â”œâ”€ printf() pour chaque fichier
   â””â”€ closedir()

[Ã‰TAPE 3.3] Programme se termine
â””â”€ exit(0)

          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FIN DE L'EXÃ‰CUTION                                          â”‚
â”‚ Le programme s'est exÃ©cutÃ© avec succÃ¨s!                     â”‚
â”‚ Le .text reste dÃ©chiffrÃ© en MÃ‰MOIRE (pas sur disque)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š RÃ‰SUMÃ‰ DES TRANSFORMATIONS

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CE QUI CHANGE DANS LE BINAIRE                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FICHIER ORIGINAL (test_ls):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Taille:         143360 bytes
  e_entry:        0x6aa0
  .text:          Plain (lisible)
  .text flags:    PF_R | PF_X
  .data:          Normal
  .data size:     0x2608
  .data flags:    PF_R | PF_W


FICHIER PACKÃ‰ (fdp):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  Taille:         140912 bytes (+152 bytes de stub)
  e_entry:        0x235d8 (pointe vers stub) â—€â”€â”€â”€ CHANGÃ‰
  .text:          ChiffrÃ© (illisible) â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CHANGÃ‰
  .text flags:    PF_R | PF_W | PF_X â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CHANGÃ‰ (+W)
  .data:          Normal + STUB injectÃ© â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CHANGÃ‰
  .data size:     0x26a0 (+152 bytes) â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CHANGÃ‰
  .data flags:    PF_R | PF_W | PF_X â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CHANGÃ‰ (+X)


NOMBRE DE MODIFICATIONS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  1. ELF Header: e_entry modifiÃ©
  2. Segment .text: p_flags |= PF_W
  3. Segment .text: Contenu chiffrÃ© (78481 bytes modifiÃ©s)
  4. Segment .data: p_filesz += 152
  5. Segment .data: p_memsz += 152
  6. Segment .data: p_flags |= PF_X
  7. Fin du fichier: +152 bytes (stub + clÃ©)

  TOTAL: 7 modifications + 78481 bytes chiffrÃ©s
```
